# 🔮 Databricks DDL Generator

A Streamlit application that generates DDL (Data Definition Language) statements for Databricks based on physical data model JSON from Ellie.ai.

## ✨ New Features (v2.1)

Based on customer feedback and real-world usage, this version includes major improvements and bug fixes:

### 🔧 Enhanced Data Type Mapping (F-1, F-2)
- **Comprehensive type mapping**: Automatically converts non-Databricks types to compatible equivalents
- **Key mappings include**:
  - `BIT` → `BOOLEAN` (addresses customer feedback)
  - `VARCHAR/CHAR` → `STRING`
  - `INTEGER` → `INT`
  - `FLOAT` → `DOUBLE`
  - `DATETIME/DATETIME2` → `TIMESTAMP`
  - `MONEY` → `DECIMAL(19,4)`
  - `NUMERIC(p,s)` → `DECIMAL(p,s)`
- **Toggle control**: "Handle non-compatible data types" checkbox allows users to enable/disable automatic mapping
- **Expandable reference**: View all supported mappings in the UI

### 🏷️ Fully Qualified Names (F-5)
- **Catalog and Schema support**: Optional fields for catalog and schema names
- **Automatic prefixing**: Tables created as `catalog.schema.table_name` format
- **Live preview**: Shows example table names as you type
- **Validation queries**: Fully qualified names used in all generated validation queries

### 🔑 Inline Primary Key Constraints (F-3)
- **Modern syntax**: Primary keys now included inline with `CREATE TABLE` statements
- **No more ALTER TABLE**: Eliminates separate `ALTER TABLE` statements for primary keys
- **Proper formatting**: Constraints properly aligned and formatted
- **Example**:
  ```sql
  CREATE TABLE Customer (
    customer_id    BIGINT    GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    name          STRING    NOT NULL,
    CONSTRAINT pk_customer PRIMARY KEY (customer_id)
  );
  ```

### ⚡ Identity Column Support (F-4)
- **Auto-detection**: Recognizes identity indicators in metadata:
  - `identity: true`
  - `generated_always: true`
  - `auto_increment: true`
  - `serial: true`
  - Keywords in descriptions ("identity", "auto increment", "serial")
- **Proper syntax**: Generates `GENERATED BY DEFAULT AS IDENTITY` or `GENERATED ALWAYS AS IDENTITY`
- **Type validation**: Only applies to numeric types (INT, BIGINT, SMALLINT, TINYINT)
- **Info tooltip**: Comprehensive documentation of supported parameters

### 🏷️ Custom Constraint Names (F-6)
- **Primary Key Names**: Override default naming with custom constraint names
- **Foreign Key Names**: Customize foreign key constraint names
- **Format**: Simple `table_name=constraint_name` format
- **Multiple relationships**: Handle multiple FKs between same tables with unique names
- **Session persistence**: Names persist during your session

### 🎨 Improved Output Formatting (F-7)
- **Column alignment**: Table columns, data types, and comments properly aligned
- **Consistent spacing**: Fixed-width formatting for better readability
- **Enhanced relationship format**: `Table Customer customer_id (PK) - Order customer_id (FK)`
- **Professional appearance**: Matches customer screenshot expectations

### 🔍 Smart Foreign Key Validation (F-8)
- **Intelligent validation**: Automatically validates FK columns against actual primary keys
- **Composite FK handling**: Converts invalid composite FKs to valid single-column FKs
- **Clear error reporting**: Detailed messages for skipped relationships with explanations
- **User control**: Toggle to enable/disable validation for legacy compatibility
- **Databricks compatibility**: Prevents `[FOREIGN_KEY_COLUMN_MISMATCH]` errors

### 🏷️ Unique Constraint Naming (F-9)
- **Conflict prevention**: Eliminates `[DELTA_CONSTRAINT_ALREADY_EXISTS]` errors
- **Attribute-based naming**: Includes target column names in constraint identifiers
- **Format**: `fk_{target_table}_{target_column}_{source_table}` for uniqueness
- **Multiple relationships**: Supports multiple foreign keys between same tables
- **Backward compatibility**: Maintains support for custom naming

### 🎯 Enhanced User Interface
- **Organized sections**: Logical grouping with icons and clear headings
- **Better tooltips**: Comprehensive help text for all options
- **Visual feedback**: Success/error messages for custom constraint names
- **Expandable sections**: Collapsible areas for advanced options
- **Data type reference**: Built-in mapping reference table

## 🚀 Features

### Core Functionality
- **JSON Parsing**: Supports Ellie.ai physical data model JSON format
- **Table Generation**: Creates `CREATE TABLE` statements with proper Databricks syntax
- **Data Type Mapping**: Converts common data types to Databricks-compatible types
- **Constraint Support**: Primary keys (inline) and foreign keys (informational)
- **Delta Format**: Automatic Delta table format specification
- **Comments**: Table and column comments from model descriptions

### Advanced Options
- **Identifier Handling**: Automatic sanitization of spaces and special characters
- **Clustering**: Optional `CLUSTERED BY` clauses for performance
- **Validation Queries**: Example SQL for data integrity validation
- **Custom Database**: Optional database creation and USE statements
- **Constraint Documentation**: Explanatory comments about Databricks constraint behavior

### Input Methods
- **Direct JSON**: Paste JSON directly into the interface
- **API Integration**: Fetch models directly from Ellie.ai API
- **Sample Data**: Built-in sample for testing and learning

## 📋 Requirements

- Python 3.7+
- Streamlit 1.28.0+
- Requests library for API calls

## 🛠️ Installation

1. Clone or download this repository
2. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```
3. Run the application:
   ```bash
   streamlit run app.py
   ```

## 🎯 Usage

### Basic Usage
1. **Start the app**: Run `streamlit run app.py`
2. **Configure options**: Set your preferences in the left sidebar
3. **Input data**: Either paste JSON or fetch from Ellie.ai API
4. **Generate DDL**: Click "Generate DDL" to create your statements
5. **Download**: Use the download button to save your DDL file

### Advanced Configuration

#### Data Type Handling
- ✅ **Enable "Handle non-compatible data types"** (recommended)
- 📖 **View mappings** in the expandable reference section
- 🔍 **Test with your data** to ensure proper type conversion

#### Fully Qualified Names
- 📝 **Catalog Name**: e.g., `env_catalog`, `production_catalog`
- 📝 **Schema Name**: e.g., `sales`, `marketing`, `data_warehouse`
- 👀 **Preview**: Live preview shows resulting table names

#### Custom Constraint Names
- **Primary Keys**: Format `Customer=pk_customer_unique`
- **Foreign Keys**: Format `Order_Customer=fk_order_customer_special`
- 💾 **Session persistence**: Names saved during your session
- 🔧 **Automatic uniqueness**: Default names now include column names to prevent conflicts

#### Identity Columns
- 🔧 **Metadata setup**: Add `identity: true` to your Ellie.ai model attributes
- 📝 **Description keywords**: Include "identity", "auto increment", or "serial"
- ⚡ **Automatic detection**: App recognizes various identity indicators

### API Integration
1. **Get your API token** from Ellie.ai
2. **Find your model ID** (numeric ID from the URL)
3. **Set environment** (usually "templates" or "app")
4. **Fetch and generate** DDL directly

## 🔍 Identifier Handling

The app handles spaces and special characters in table/column names:

### Methods
- **Underscore (Recommended)**: `"Customer ID"` → `Customer_ID`
- **Backtick**: `"Customer ID"` → `` `Customer ID` ``

### Databricks Compatibility
⚠️ **Important**: Databricks Delta tables have limitations with special characters. The underscore method is strongly recommended for compatibility.

**Special Note on Catalog/Schema Names**: Databricks does not support dots (.) in catalog or schema names. If you enter names like `crm.sales`, they will be automatically sanitized to `crm_sales` to prevent `[SCHEMA_NOT_FOUND]` errors.

## 🔗 Constraint Support

### Primary Keys
- **Inline constraints**: Included directly in `CREATE TABLE` statements
- **Identity support**: Automatic identity column generation
- **Custom naming**: Override default constraint names

### Foreign Keys
- **Two approaches**:
  - **ALTER TABLE statements**: Full constraint syntax (informational only)
  - **Comments only**: Relationship documentation without constraints
- **Enhanced format**: Clear relationship descriptions
- **Custom naming**: Override default foreign key names
- **Smart validation**: Automatically validates FK columns against actual primary keys
- **Databricks compatibility**: Prevents common FK errors by ensuring columns match

### Important Notes
- 📝 **Informational only**: Databricks constraints are not enforced
- 🔍 **Validation queries**: Use generated examples to check data integrity
- 📚 **Documentation**: Comprehensive comments explain constraint behavior
- ⚡ **Runtime requirement**: Databricks Runtime 11.2+ for foreign key syntax

## 📊 Sample Data

The app includes comprehensive sample data demonstrating:
- Multiple entity types (Customer, Order, Product, etc.)
- Various data types (including BIT, VARCHAR, DATETIME)
- Primary and foreign key relationships
- Table and column descriptions
- Identity column examples

## 🧪 Testing

Run the test suite to verify functionality:
```bash
python test_core_functions.py
```

Tests cover:
- ✅ Data type mapping (including BIT → BOOLEAN)
- ✅ Identity column support
- ✅ Column formatting and alignment
- ✅ Identifier sanitization

## 📝 Generated DDL Example

```sql
-- DDL for Sample E-commerce Model
-- Note: In Databricks, primary key and foreign key constraints are declarative and not enforced

CREATE DATABASE IF NOT EXISTS sample_e_commerce_model;
USE sample_e_commerce_model;

CREATE TABLE IF NOT EXISTS env_catalog.sales.Customer (
  customer_id          BIGINT          GENERATED BY DEFAULT AS IDENTITY NOT NULL COMMENT 'Unique customer identifier',
  first_name           STRING          NOT NULL COMMENT 'Customer first name',
  last_name            STRING          NOT NULL COMMENT 'Customer last name',
  email                STRING          NOT NULL COMMENT 'Customer email address',
  created_at           TIMESTAMP       NOT NULL COMMENT 'Account creation timestamp',
  CONSTRAINT pk_customer_unique PRIMARY KEY (customer_id)
)
COMMENT 'Customer information table'
USING DELTA;

CREATE TABLE IF NOT EXISTS env_catalog.sales.Order (
  order_id             BIGINT          GENERATED BY DEFAULT AS IDENTITY NOT NULL COMMENT 'Unique order identifier',
  customer_id          BIGINT          NOT NULL COMMENT 'Reference to customer',
  order_date           TIMESTAMP       NOT NULL COMMENT 'Order placement date',
  total_amount         DECIMAL(19,4)   NOT NULL COMMENT 'Total order amount',
  status               STRING          NOT NULL COMMENT 'Order status',
  CONSTRAINT pk_order PRIMARY KEY (order_id)
)
COMMENT 'Order information table'
USING DELTA;

-- Adding Foreign Key Constraints (Informational, not enforced)
-- Note: Foreign key columns must match primary key columns exactly
ALTER TABLE env_catalog.sales.Order ADD CONSTRAINT fk_order_customer_id_customer 
FOREIGN KEY (customer_id) REFERENCES env_catalog.sales.Customer(customer_id);
```

## 🤝 Contributing

This tool was developed based on customer feedback. Future improvements welcome:

1. **Enhanced type mapping**: Additional database type support
2. **UI improvements**: Better visual design and user experience  
3. **Validation features**: More comprehensive data integrity checks
4. **Export options**: Additional output formats (YAML, JSON, etc.)

## 📄 License

MIT License - see LICENSE file for details.

## 🔗 Related Links

- [Databricks SQL Reference](https://docs.databricks.com/sql/language-manual/index.html)
- [Databricks Constraints Documentation](https://docs.databricks.com/en/tables/constraints.html)
- [Delta Lake Documentation](https://docs.delta.io/)
- [Ellie.ai Documentation](https://ellie.ai/docs)

---

**Version 2.1** - Enhanced with comprehensive customer feedback improvements and production-ready bug fixes 